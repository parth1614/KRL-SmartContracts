// SPDX-License-Identifier: MIT

/**
 *Submitted for verification at polygonscan.com on 2021-11-18
*/

interface IERC20 {
    function totalSupply() external view returns (uint);

    function balanceOf(address account) external view returns (uint);

    function transfer(address recipient, uint amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";

contract vesting is KeeperCompatibleInterface{
  struct user{
    // address RETHuser;
    uint RETHamountTotal;
    uint RETHamountperDay;
    uint lastTimeStamp;
  }
    IERC20 public RETH;
    // uint RETHperDAY;
    // uint DeservingRETH;
    uint i = 0;
    uint count = 0;
   mapping(address => user) public users;
   mapping(uint=>address) private all_users;

 
  address public admin;

 
  constructor(address tok) {
    admin = msg.sender;
    RETH = IERC20(tok); 
  }    

  function getRETHamout(address _RETHuser) public returns(uint,uint){
    uint DeservingRETH = RETH.balanceOf(_RETHuser);
    uint RETHperDAY = RETH.balanceOf(_RETHuser)/63072000;
    return (DeservingRETH,RETHperDAY); 
  }

  function setRETHamount(address _RETHuser) public {
     //this function will be replaced by burning function
    (uint DeservingRETH,uint Rethperday) = getRETHamout(_RETHuser);
    // RETH.transfer(address(this),RETH.balanceOf(_RETHuser));
    user memory instance;
    instance.RETHamountperDay = Rethperday;
    instance.RETHamountTotal = DeservingRETH;
    instance.lastTimeStamp = block.timestamp;
    all_users[count] = _RETHuser;
    users[_RETHuser] = instance;
    count++;
  }
  

  function checkUpkeep(bytes calldata /* checkData /) external view override returns (bool upkeepNeeded, bytes memory / performData */) public {
       bool upkeepNeeded;
       
        for(i=0; i < count ;i++){
          // user memory instance = users[all_users[i]];
          if(upkeepNeeded = (block.timestamp - users[all_users[i]].lastTimeStamp) > 86400){
            return upkeepNeeded;
          }
          else if(i>=count-1){
          i=0;
          }
//set function accordingly
        }       
        // We don"t use the checkData in this example. The checkData is defined when the Upkeep was registered.
  }
      
    function performUpkeep(bytes calldata /* performData */) external override {
        user storage instance = users[all_users[i]];
        // (uint DeservingRETH,uint Rethperday) = (all_users[i]);       
        instance.lastTimeStamp = block.timestamp;
        require(instance.RETHamountperDay > 0);
        require(instance.RETHamountTotal >= instance.RETHamountperDay,"All tokens withdrawn");
          // address(this).transfer(all_users[i],instance.RETHamountperDay);
        instance.RETHamountTotal -= instance.RETHamountperDay;
        RETH.transfer(all_users[i],instance.RETHamountperDay);
         //RETH will be minted and transfered into this contract.
        // emit addUserEvent(msg.sender, user.RETHamount ,"RETH claimed for today");
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }
}


///////////



pragma solidity 0.8.11;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol";

contract XYZ is ERC20{
    
    constructor() ERC20('Testing','XYZ'){
        _mint(msg.sender,100000000 * 10 ** 18);
    }
    
}

